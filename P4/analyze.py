import numpy as np
import matplotlib.pyplot as plt

# Information about the dimmensjons of the data set
meta = np.loadtxt("results/meta.txt", usecols=0)

cycles = int(meta[0])
cores = int(meta[1])
L = int(meta[2])
T = float(meta[3])

# data set generated by the Monte Carlo simulation
file = "results/data.dat"
array = np.fromfile(file, dtype="int32", count=-1)

cutoff = 500  # Number of cycles to ignore before calculating expection values
length = (cycles - cutoff) * cores

E = np.zeros((cores, cycles))
M = np.zeros((cores, cycles))

for i in range(cores):
    start = 2 * cycles * i
    end = 2 * cycles * i + cycles
    E[i] = array[start:end]
    M[i] = array[(start + cycles):(end + cycles)]

E_mean = 0
M_mean = 0
E2 = 0
M2 = 0

for i in range(cores):
    truncE = E[i, cutoff:cycles]  # Cuts off the start of each array
    truncM = M[i, cutoff:cycles]

    E_mean += sum(truncE)  # Calculates the mean
    M_mean += sum(truncM)

    E2 += sum(truncE**2)
    M2 += sum(truncM**2)


E_mean /= length  # Normalizes
M_mean /= length
E2 /= length
M2 /= length

Cv = 1 / T**2 * (E2 - E_mean**2)
X = 1 / T * (M2 - M_mean**2)

print("T = %s" % T)
print("Energy = %s" % E_mean)
print("Magnetization = %s" % M_mean)
print("Heat Capacity  = %s" % Cv)
print("Susceptibility  = %s" % X)

np.savetxt("results/expection.txt", (T, E_mean, M_mean, Cv, X))

P = {}
# Goes though the different enegy states that occured and counts how often they
# occured
for i in range(cores):
    for j in range(cycles):
        energy = E[i, j]
        if energy in P:
            P[energy] += 1
        else:
            P[energy] = 1

# Normalizes the probability
for p in P:
    P[p] /= cycles * cores

state = list(P.values())  # state of a specific energy
prob = list(P.keys())     # probaility of energy to occur

np.savetxt("results/distribution.txt", np.transpose((prob, state)))
plt.show()
